# 책임 연쇄 패턴 (Chain of responsibility Pattern)

클라이언트의 요청을 각기 다른 책임을 하는 클래스들이 연쇄적으로 처리하는 패턴

이름 그대로 각기 다른 책임을 가진 클래스가 체인처럼 연결되어 자신의 책임을 수행한 뒤 다음 클래스에게 작업을 전달하는 패턴이다.  
클라이언트는 요청을 처리하는 클래스들이 어떠한 책임을 담당하고 있는지 알 필요가 없다. 체인을 생성하는 곳에서 각 클래스들이 어떠한 순서로 어떻게 연결되어 있는지 결정하므로 요청을 하는 쪽과 요청을 처리하는 쪽의 결합도가 느슨해진다. 또한 중간에 다른 과정이 추가되더라도 기존의 요청을 하는 코드나 요청을 처리하는 코드 모두 수정할 필요가 없다. 단지 클래스를 하나 만들고, 체인을 생성하는 곳에서 해당 클래스를 추가해주면 되는 것이다.

예를 들어 사용자의 닉네임을 만들 때 아래와 같은 프로세스를 거친다고 생각해보자.

```
1. 닉네임의 길이가 2자 이상 10자 이내인지 확인한다.
2. 닉네임에 비속어가 포함되어 있는지 확인한다.
3. 이미 사용 중인 닉네임인지 확인한다.
4. 닉네임에 아이디를 저장한다.
```

각각의 프로세스는 각자 검증 과정을 거친 후 오류가 없을 경우에만 다음 프로세스에게 책임을 전달한다. 1-3번의 프로세스 중 하나라도 통과하지 않는다면 최종으로 닉네임을 저장하는 과정이 진행되지 않는다. 또한 2번과 3번 사이에 사용자의 닉네임에 개인 정보가 노출되지 않도록 확인하는 절차가 추가될 수도 있다. 책임 연쇄 패턴은 이러한 각 단일 책임을 가진 클래스들을 연결하고, 각 클래스에서 다음 클래스로 작업을 전달할지 여부를 결정할 수 있다. 또한 모든 체인이 완료된 이후에 중간의 클래스에서 특정한 작업을 수행하도록 체인을 구성할 수도 있다.  
객체지향 설게의 원칙에서 책임 연쇄 패턴은 단일 책임의 원칙과 개방 폐쇄의 원칙을 준수한다. 각 클래스는 각각 단일의 책임을 가지고 있으며, 특정한 기능이 추가되거나 삭제되더라도 기존의 코드를 수정하지 않아도 된다.

## 데코레이터 패턴과 차이

각 클래스에 다른 클래스를 파라미터로 전달하고, 각 클래스의 기능을 끝내면 전달된 클래스에게 다음 일을 전달하는 패턴이 데코레이터 패턴과 책임 연쇄 패턴이 유사하게 보인다. 하지만 패턴의 목적 측면에서 데코레이터 패턴과 책임 연쇄 패턴은 다른 차이를 보인다. 데코레이터 패턴은 다양한 기능을 추가하는데 중점을 두는 반면, 책임 연쇄 패턴은 클라이언트의 요청이 여러 책임을 지나가 실행되는 것에 중점을 두고 설계한다.    
데코레이터 패턴은 클라이언트 측에서 자유롭게 필요한 기능을 추가하거나 삭제할 수 있자만 책임 연쇄 패턴은 클라이언트가 그 요청을 어떻게 처리하는지 알 수 없도록 숨긴다. 또한 책임 연쇄 패턴은 각 클래스에서 다음 클래스로 작업을 전달할지 여부를 결정하고 체인을 끊을 수도 있으며, 모든 체인을 다 실행한 뒤 중간 클래스에서 콜백을 추가하여 실행할 수도 있다. 하지만 데코레이터 패턴은 기능을 덧붙이는 것이 주 목적이므로 자신의 책임 이외의 다른 책임의 실행 여부에는 관여하지 않으며, 그저 자신의 책임을 다 한뒤 다음의 기능이 실행될 수 있도록 전달해줄 뿐이다 .
